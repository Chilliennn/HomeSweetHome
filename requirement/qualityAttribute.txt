Reusability Rules (Reuse First)

Search first, then create

Before building any new UI component, always check directories such as components/ui and components/common.

If an existing component already satisfies 70% or more of your needs, you should extend or parameterize that component instead of creating a new one that looks similar but has a different name.

Merge similar components

After pulling the latest code from GitHub, if you find two or more components that:

Look similar (buttons, cards, list items, form fields, etc.), or

Behave similarly (confirmation modals, error alerts, loading states)

You must evaluate whether they can be merged into a more generic component, controlled through props for style/text variations.

Duplicate UI patterns across folders are not allowed
(e.g., two almost identical PrimaryButton components).

Clear naming & responsibility-based splitting

Principle: One visual pattern = One base component.

Examples:

All primary buttons → PrimaryButton

All error messages → ErrorMessage

All inputs with label + error → LabeledTextField

Names like BigButton, AnotherButton, BlueButton2 are not allowed.

Maintainability Rules
UI handles presentation only; logic goes into ViewModel / Service

All network requests, database access, and business rules
(e.g., pre-match restrictions, 7-day rules) must be placed in Service / ViewModel.

Views/components should ONLY:

Receive props/state and display data

Call methods exposed by the ViewModel

Components must not directly use Supabase / fetch / axios.

Avoid copy-paste logic

If you write code in a second place that is 80% similar to an earlier one:

Stop and extract that logic into:

a shared ViewModel method, or

a shared component function / hook / util

During review/merge, if duplicate logic is found, refactor it into common code.

Single Responsibility (Small, focused components)

Each component/file should handle exactly one concern:

ProfileInfoForm: only the UI, no saving

ProfileInfoViewModel: handles saving logic and state

When a file grows beyond ~300 lines or holds multiple responsibilities, consider splitting it.

Centralized state management

State related to a single business domain
(e.g., relationship stage, pre-match status, unread counters)
must be stored in the corresponding ViewModel.

Do not let each page maintain its own duplicate copy of the same business state.

If multiple pages need the same state, they must share the same ViewModel or a shared store.

Unified styling and interactions

Repeated styles (button colors, borders, font sizes) must come from a unified theme/style constants file.

New UI designs should align with existing components rather than inventing new styles.

Checkpoints in the Development Process
Before Development

For every new requirement, search in:

components/ui

viewmodels

services

If something similar exists → reuse/extend
If nothing exists → create a new one.

Before Commit (Self-Review)

Check whether your new component is just a slightly modified version of an existing one.
If yes → consider merging.

Check whether you wrote business logic or accessed DB/Service directly in the View.
If yes → move it to ViewModel/Service.

After Merge/Pull

After pulling from GitHub, review:

Did any two similar UI components appear?

Are there two duplicated business logic blocks?

If yes, create a refactor task to merge them into a single implementation.